---
phase: 02-lead-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crm-dashboard/components/OrderDetailModal.tsx
  - crm-dashboard/components/LeadMatchingPanel.tsx
  - crm-dashboard/app/api/orders/[id]/match/route.ts
autonomous: false

must_haves:
  truths:
    - "User sees 'Match to Lead' button in order modal when order has no lead_id"
    - "Clicking 'Match to Lead' shows suggested leads ranked by similarity"
    - "User can confirm a match and see the order immediately linked to the lead"
  artifacts:
    - path: "crm-dashboard/components/LeadMatchingPanel.tsx"
      provides: "Lead suggestion UI with similarity scoring"
      exports: ["LeadMatchingPanel"]
      min_lines: 80
    - path: "crm-dashboard/app/api/orders/[id]/match/route.ts"
      provides: "API endpoint to update order's lead_id"
      exports: ["PATCH"]
      min_lines: 30
    - path: "crm-dashboard/components/OrderDetailModal.tsx"
      provides: "Modal with Match to Lead button for unmatched orders"
      contains: "Match to Lead"
  key_links:
    - from: "crm-dashboard/components/OrderDetailModal.tsx"
      to: "LeadMatchingPanel.tsx"
      via: "conditional render when matching mode active"
      pattern: "LeadMatchingPanel"
    - from: "crm-dashboard/components/LeadMatchingPanel.tsx"
      to: "/api/orders/[id]/match"
      via: "fetch PATCH request"
      pattern: "fetch.*api/orders.*match"
    - from: "LeadMatchingPanel.tsx"
      to: "leads table"
      via: "supabase query for suggestions"
      pattern: "from.*leads"
---

<objective>
Add manual lead matching to the order detail modal with smart suggestions.

Purpose: Users need to connect unmatched Toast orders to existing leads when auto-matching (by exact email/phone) misses the connection. This enables accurate revenue attribution to marketing campaigns.

Output: OrderDetailModal shows "Match to Lead" button for unmatched orders, opens a panel with ranked lead suggestions, and allows user to confirm a match.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

# Existing files to modify/reference
@crm-dashboard/components/OrderDetailModal.tsx
@crm-dashboard/app/(dashboard)/orders/page.tsx
@crm-dashboard/types/lead.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LeadMatchingPanel component with similarity scoring</name>
  <files>crm-dashboard/components/LeadMatchingPanel.tsx</files>
  <action>
Create a component that suggests leads for matching based on similarity to order customer data.

Props interface:
```typescript
interface LeadMatchingPanelProps {
  orderId: string
  clientId: string
  customerName: string | null    // Combined first + last from order
  customerEmail: string | null
  customerPhone: string | null
  onMatch: (leadId: string) => void
  onCancel: () => void
}
```

On mount, fetch leads for this client and compute similarity scores:

```typescript
const { data: leads } = await supabase
  .from('leads')
  .select('id, first_name, last_name, email, phone')
  .eq('client_id', clientId)
  .limit(100)  // Reasonable limit for client-side scoring
```

Similarity scoring algorithm (simple and effective):
```typescript
function computeScore(lead: Lead, customerName: string | null, customerEmail: string | null, customerPhone: string | null): number {
  let score = 0

  // Email match (highest weight) - exact match, case insensitive
  if (customerEmail && lead.email) {
    if (lead.email.toLowerCase() === customerEmail.toLowerCase()) {
      score += 100  // Exact email = very likely match
    }
  }

  // Phone match (high weight) - normalize to digits only
  if (customerPhone && lead.phone) {
    const orderPhone = customerPhone.replace(/\D/g, '')
    const leadPhone = lead.phone.replace(/\D/g, '')
    if (orderPhone && leadPhone && orderPhone === leadPhone) {
      score += 80
    } else if (orderPhone && leadPhone && (orderPhone.includes(leadPhone) || leadPhone.includes(orderPhone))) {
      score += 40  // Partial phone match (missing area code, etc.)
    }
  }

  // Name match (medium weight) - case insensitive contains
  if (customerName) {
    const orderNameLower = customerName.toLowerCase()
    const leadFullName = `${lead.first_name} ${lead.last_name}`.toLowerCase()

    // Exact full name match
    if (leadFullName === orderNameLower) {
      score += 60
    }
    // First name match
    else if (lead.first_name && orderNameLower.includes(lead.first_name.toLowerCase())) {
      score += 30
    }
    // Last name match
    else if (lead.last_name && orderNameLower.includes(lead.last_name.toLowerCase())) {
      score += 30
    }
  }

  return score
}
```

Sort leads by score descending, show top 5 with score > 0. If no suggestions have score > 0, show message "No similar leads found" with option to search all leads.

UI layout:
1. Header: "Match to Lead" with close (X) button
2. Order customer info summary (what we're matching against)
3. Suggested leads list (top 5 by score):
   - Each row: Lead name, email, phone
   - Similarity indicator (High/Medium/Low based on score thresholds: >80 High, >40 Medium, else Low)
   - "Select" button
4. Search fallback: Text input to search all leads by name/email
5. Footer: Cancel button

When user clicks "Select" on a lead:
1. Call onMatch(leadId) - parent handles the API call
2. Show brief loading state

Tailwind styling consistent with OrderDetailModal:
- Container: bg-white rounded-lg shadow p-4
- Section headers: text-sm font-semibold text-gray-900 mb-2
- Lead rows: p-3 border border-gray-200 rounded-md hover:bg-gray-50 cursor-pointer
- High match badge: bg-green-100 text-green-800
- Medium match badge: bg-yellow-100 text-yellow-800
- Low match badge: bg-gray-100 text-gray-800
  </action>
  <verify>
Run `npm run build` in crm-dashboard - should compile without errors.
Run `npm run lint` - should pass.
Inspect component exports LeadMatchingPanel and has similarity scoring logic.
  </verify>
  <done>
LeadMatchingPanel.tsx exists, exports LeadMatchingPanel, fetches leads, computes similarity scores (email > phone > name), displays top 5 suggestions with match indicators, handles search fallback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API endpoint to update order's lead_id</name>
  <files>crm-dashboard/app/api/orders/[id]/match/route.ts</files>
  <action>
Create a PATCH endpoint to update an order's lead_id.

Route: PATCH /api/orders/[id]/match
Body: { leadId: string }

Implementation:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const supabase = createClient()

  // Verify authentication
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // Parse request body
  const { leadId } = await request.json()
  if (!leadId) {
    return NextResponse.json({ error: 'leadId required' }, { status: 400 })
  }

  // Update the order's lead_id
  // RLS policy ensures user can only update orders they have access to
  const { data, error } = await supabase
    .from('toast_orders')
    .update({ lead_id: leadId })
    .eq('id', params.id)
    .select('id, lead_id')
    .single()

  if (error) {
    console.error('Error matching order to lead:', error)
    return NextResponse.json({ error: 'Failed to match order' }, { status: 500 })
  }

  return NextResponse.json({ success: true, order: data })
}
```

The endpoint:
- Requires authentication (returns 401 if not logged in)
- Validates leadId is provided (returns 400 if missing)
- Uses Supabase RLS for authorization (client users can only update their own client's orders)
- Returns updated order data on success
  </action>
  <verify>
Run `npm run build` in crm-dashboard - should compile without errors.
File exists at app/api/orders/[id]/match/route.ts with PATCH export.
  </verify>
  <done>
API endpoint exists, accepts PATCH with leadId, updates toast_orders.lead_id, returns success response.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire matching UI into OrderDetailModal</name>
  <files>crm-dashboard/components/OrderDetailModal.tsx</files>
  <action>
Modify OrderDetailModal to show "Match to Lead" button for unmatched orders and integrate LeadMatchingPanel.

Add state for matching mode:
```typescript
const [isMatching, setIsMatching] = useState(false)
const [matchSuccess, setMatchSuccess] = useState(false)
```

Add handler for match completion:
```typescript
const handleMatch = async (leadId: string) => {
  try {
    const response = await fetch(`/api/orders/${order.id}/match`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ leadId }),
    })

    if (!response.ok) {
      throw new Error('Failed to match')
    }

    setMatchSuccess(true)
    setIsMatching(false)

    // Close modal after brief delay to show success
    setTimeout(() => {
      onClose()
    }, 1500)
  } catch (error) {
    console.error('Match error:', error)
    // Could add error state/toast here
  }
}
```

In the modal header area (after the voided badge, before close button), conditionally show:

If order.lead_id is null AND not matching AND not matchSuccess:
```jsx
<button
  onClick={() => setIsMatching(true)}
  className="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700"
>
  Match to Lead
</button>
```

If matchSuccess:
```jsx
<span className="px-3 py-1 text-sm bg-green-100 text-green-800 rounded-md">
  Matched!
</span>
```

When isMatching is true, render LeadMatchingPanel instead of the normal modal content:
```jsx
{isMatching ? (
  <LeadMatchingPanel
    orderId={order.id}
    clientId={order.client_id}
    customerName={[order.customer_first_name, order.customer_last_name].filter(Boolean).join(' ') || null}
    customerEmail={order.customer_email}
    customerPhone={order.customer_phone}
    onMatch={handleMatch}
    onCancel={() => setIsMatching(false)}
  />
) : (
  // existing modal content (customer section, items, payments)
)}
```

Import the LeadMatchingPanel at top of file:
```typescript
import { LeadMatchingPanel } from './LeadMatchingPanel'
```
  </action>
  <verify>
Run `npm run build` in crm-dashboard - should compile without errors.
Run `npm run dev`, navigate to /orders.
Find an unmatched order (lead_id is null) - should show "Match to Lead" button in modal.
Click button - should show LeadMatchingPanel.
  </verify>
  <done>
OrderDetailModal shows "Match to Lead" button for unmatched orders, clicking opens LeadMatchingPanel, successful match updates order and shows success state.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify lead matching flow end-to-end</name>
  <what-built>
Lead matching feature:
- "Match to Lead" button appears for unmatched orders
- Clicking opens panel with suggested leads ranked by similarity
- User can select a lead to confirm the match
- Match persists to database
  </what-built>
  <how-to-verify>
Test the matching flow:

1. Navigate to /orders page
2. Filter by "Unmatched" to find orders without a lead
3. Click an unmatched order to open detail modal
4. Verify "Match to Lead" button appears in header area
5. Click "Match to Lead" button
6. Verify LeadMatchingPanel opens showing:
   - Order customer info at top (name, email, phone if available)
   - Suggested leads with similarity indicators (High/Medium/Low)
   - Leads should be ranked by score (best matches first)
7. Click "Select" on one of the suggested leads
8. Verify success message appears briefly
9. Modal should close automatically
10. Verify in orders list: that order should now show the matched lead name
11. Re-open the order modal - "Match to Lead" button should NOT appear (already matched)

Edge cases to test:
- Order with no customer info: Should show "No similar leads found" with search fallback
- Order that already has a lead: Should NOT show "Match to Lead" button
  </how-to-verify>
  <resume-signal>Type "approved" if matching flow works correctly, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. Orders page loads at /orders
3. Unmatched orders show "Match to Lead" button in modal
4. Matched orders do NOT show "Match to Lead" button
5. LeadMatchingPanel shows suggested leads with similarity scores
6. Selecting a lead calls API and updates order
7. Success state shows after matching
8. Order table reflects the new match
</verification>

<success_criteria>
- MATCH-01: Unmatched orders show "Match to Lead" button
- MATCH-02: Matching UI shows smart suggestions based on name/phone similarity
- MATCH-03: User can confirm match and save to update order
</success_criteria>

<output>
After completion, create `.planning/phases/02-lead-matching/02-01-SUMMARY.md`
</output>
