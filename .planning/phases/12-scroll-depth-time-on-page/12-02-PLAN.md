---
phase: 12-scroll-depth-time-on-page
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crm-dashboard/app/(dashboard)/analytics/components/sections/ScrollDepth.tsx
  - crm-dashboard/app/(dashboard)/analytics/components/ShrikeAnalytics.tsx
autonomous: true

must_haves:
  truths:
    - "ScrollDepth section appears in Deep Dive tab after GeoDistribution"
    - "When scroll events exist, section shows per-page milestone achievement rates (25/50/75/90/100%)"
    - "When no scroll events exist, section shows 'No scroll depth data yet' empty state"
    - "Achievement rates are calculated as: unique sessions reaching milestone / total sessions for that page"
    - "Summary stats show pages tracked, average max scroll depth, and most-read page"
  artifacts:
    - path: "crm-dashboard/app/(dashboard)/analytics/components/sections/ScrollDepth.tsx"
      provides: "Scroll depth analytics section"
      exports: ["ScrollDepth"]
      min_lines: 60
    - path: "crm-dashboard/app/(dashboard)/analytics/components/ShrikeAnalytics.tsx"
      provides: "Deep Dive tab with ScrollDepth wired in"
      contains: "ScrollDepth"
  key_links:
    - from: "ScrollDepth.tsx"
      to: "visits array"
      via: "filters for event_name === 'scroll_depth'"
      pattern: "event_name.*scroll_depth"
    - from: "ShrikeAnalytics.tsx"
      to: "ScrollDepth"
      via: "import and render in Deep Dive tab"
      pattern: "import.*ScrollDepth"
---

<objective>
Create ScrollDepth analytics section component for the CRM dashboard and wire it into the Deep Dive tab.

Purpose: Visualize scroll depth data showing per-page milestone achievement rates so users can identify which pages visitors actually read vs bounce from. Follows the established section component pattern from Phase 9.

Output: New ScrollDepth.tsx section component rendered in the Deep Dive tab, showing scroll milestone breakdown per page with summary stats.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-referrer-analysis-geo-distribution/11-01-SUMMARY.md

Working directory: C:\Users\steph\OneDrive\Desktop\claude\Nessus

Existing patterns to follow:
@crm-dashboard/app/(dashboard)/analytics/components/sections/ReferrerAnalysis.tsx
@crm-dashboard/app/(dashboard)/analytics/components/shared/types.ts
@crm-dashboard/app/(dashboard)/analytics/components/shared/StatCard.tsx
@crm-dashboard/app/(dashboard)/analytics/components/ShrikeAnalytics.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScrollDepth section component</name>
  <files>crm-dashboard/app/(dashboard)/analytics/components/sections/ScrollDepth.tsx</files>
  <action>
Create `ScrollDepth.tsx` following the exact section component pattern from ReferrerAnalysis.tsx and other Phase 9-11 sections.

Function signature: `export function ScrollDepth({ visits }: { visits: Visit[] })`

Imports:
- `useMemo` from react
- `Visit` from `../shared/types`
- `StatCard` from `../shared/StatCard`

Add `'use client'` directive at top.

**Data computation via useMemo:**

1. Filter scroll events: `visits.filter(v => v.event_name === 'scroll_depth' && v.event_data?.percent_scrolled)`

2. Count total sessions (page views) per page. A "page view" is a visit with `event_name === null` (no event = page view). Group by `page_path`:
   ```
   const pageViewsByPage = new Map<string, Set<string>>()
   visits.filter(v => !v.event_name && v.page_path && v.session_id).forEach(v => {
     if (!pageViewsByPage.has(v.page_path!)) pageViewsByPage.set(v.page_path!, new Set())
     pageViewsByPage.get(v.page_path!)!.add(v.session_id!)
   })
   ```

3. Group scroll events by page_path, then for each page count unique sessions that reached each milestone:
   ```
   const pageScrollData = new Map<string, Map<number, Set<string>>>()
   // For each scroll event, track which session_ids reached which milestones per page
   scrollEvents.forEach(event => {
     const page = event.page_path || 'Unknown'
     const percent = event.event_data.percent_scrolled as number
     const sessionId = event.session_id
     if (!sessionId) return
     if (!pageScrollData.has(page)) pageScrollData.set(page, new Map())
     const milestones = pageScrollData.get(page)!
     if (!milestones.has(percent)) milestones.set(percent, new Set())
     milestones.get(percent)!.add(sessionId)
   })
   ```

4. Calculate achievement rates per page:
   - For each page in pageScrollData, get total sessions from pageViewsByPage (fallback: count unique session_ids in scroll events for that page)
   - For each milestone (25, 50, 75, 90, 100): `(sessionsReaching / totalSessions) * 100`
   - Sort pages by total sessions descending (most visited first)

5. Calculate summary stats:
   - `pagesTracked`: number of unique pages with scroll data
   - `avgMaxScroll`: across all sessions with scroll data, find the max milestone each session reached, then average those. For example, if session A reached 75% and session B reached 50%, avgMaxScroll = 62.5%. Round to nearest integer.
   - `mostReadPage`: the page with the highest 100% achievement rate (or highest average milestone if no 100% data). Show just the path, truncated if needed.

**Empty state:**
If no scroll events found, render:
```tsx
<div className="bg-white rounded-lg shadow p-6 mb-8">
  <h2 className="text-lg font-semibold text-gray-900 mb-4">Scroll Depth</h2>
  <p className="text-gray-500 text-sm">No scroll depth data yet. Scroll tracking will appear here once visitors interact with pages that have scroll depth tracking enabled.</p>
</div>
```

**Rendering (when data exists):**

1. Summary stats row (3 StatCards in a grid-cols-3 grid):
   - Pages Tracked (blue)
   - Avg Max Scroll (green, show as percentage like "72%")
   - Most-Read Page (purple, show truncated page path)

2. Per-page scroll depth table. For each page, show:
   - Page path as header (truncate long paths, show last 2 segments if path > 30 chars)
   - Total sessions count
   - Horizontal milestone bars for 25%, 50%, 75%, 90%, 100%:
     - Each bar shows the milestone label on the left, a colored horizontal bar proportional to achievement rate, and the percentage on the right
     - Color gradient: 25% = green-400, 50% = blue-400, 75% = yellow-400, 90% = orange-400, 100% = red-400
     - Bar container: `bg-gray-200 rounded-full h-2` (same pattern as ReferrerAnalysis)
     - Bar fill: `h-2 rounded-full` with dynamic width and background color

3. Limit to top 10 pages (by session count). If more than 10 pages, don't show a "show more" -- just show top 10.

Wrapper: `<div className="bg-white rounded-lg shadow p-6 mb-8">` (matches all other sections)
  </action>
  <verify>
1. File exists and exports ScrollDepth function component
2. TypeScript compiles: `cd C:\Users\steph\OneDrive\Desktop\claude\Nessus\crm-dashboard && npx tsc --noEmit`
  </verify>
  <done>
  - ScrollDepth.tsx created with useMemo computation, empty state, summary stats, and per-page milestone bars
  - Follows section component pattern (Visit prop, useMemo, StatCard, bg-white rounded-lg shadow wrapper)
  - Achievement rates calculated as unique sessions reaching milestone / total page view sessions
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ScrollDepth into ShrikeAnalytics Deep Dive tab</name>
  <files>crm-dashboard/app/(dashboard)/analytics/components/ShrikeAnalytics.tsx</files>
  <action>
Two changes to ShrikeAnalytics.tsx:

1. Add import at the top with the other section imports:
   `import { ScrollDepth } from './sections/ScrollDepth'`

2. Add `<ScrollDepth visits={visits} />` as the LAST section in the Deep Dive tab, after `<GeoDistribution visits={visits} />`:
   ```tsx
   <>
     <SessionJourneys visits={visits} />
     <TimeOnPage visits={visits} />
     <ReferrerAnalysis visits={visits} />
     <GeoDistribution visits={visits} />
     <ScrollDepth visits={visits} />
   </>
   ```

No other changes needed. The Supabase query already fetches event_name and event_data, so scroll_depth events will be included automatically in the visits array.
  </action>
  <verify>
1. Build succeeds: `cd C:\Users\steph\OneDrive\Desktop\claude\Nessus\crm-dashboard && npm run build`
2. Verify import and rendering by reading the file
  </verify>
  <done>
  - ShrikeAnalytics.tsx imports ScrollDepth and renders it in Deep Dive tab
  - Build passes with no errors
  - Deep Dive tab now has 5 sections: SessionJourneys, TimeOnPage, ReferrerAnalysis, GeoDistribution, ScrollDepth
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd C:\Users\steph\OneDrive\Desktop\claude\Nessus\crm-dashboard && npx tsc --noEmit`
2. Production build: `cd C:\Users\steph\OneDrive\Desktop\claude\Nessus\crm-dashboard && npm run build`
3. ScrollDepth.tsx exists, exports ScrollDepth, follows section component pattern
4. ShrikeAnalytics.tsx imports and renders ScrollDepth in Deep Dive tab
5. Empty state renders correctly (no scroll_depth events in current data = shows "No scroll depth data yet")
</verification>

<success_criteria>
- ScrollDepth section component created following established pattern (Visit prop, useMemo, StatCard, section wrapper)
- Wired into Deep Dive tab as 5th section after GeoDistribution
- Empty state shows informative message when no scroll data exists
- When scroll data exists: summary stats + per-page milestone achievement bars
- Achievement rates use correct denominator (page view sessions, not scroll event count)
- Production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/12-scroll-depth-time-on-page/12-02-SUMMARY.md`

Git commit in Nessus repo:
```
cd C:\Users\steph\OneDrive\Desktop\claude\Nessus
git add crm-dashboard/app/(dashboard)/analytics/components/sections/ScrollDepth.tsx crm-dashboard/app/(dashboard)/analytics/components/ShrikeAnalytics.tsx
git commit -m "feat(analytics): add ScrollDepth section to Deep Dive tab"
```
</output>
