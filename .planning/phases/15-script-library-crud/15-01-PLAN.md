---
phase: 15-script-library-crud
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crm-dashboard/package.json
  - crm-dashboard/types/script.ts
  - crm-dashboard/lib/schemas/scriptSchema.ts
  - crm-dashboard/components/ui/dialog.tsx
  - crm-dashboard/components/ui/textarea.tsx
  - crm-dashboard/components/AddEditScriptDialog.tsx
  - crm-dashboard/components/ScriptCard.tsx
  - crm-dashboard/components/ScriptManager.tsx
  - crm-dashboard/app/(dashboard)/leads/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can see a list of active call scripts on the Cold Calling leads page"
    - "User can create a new script with title and body via a dialog form"
    - "User can edit an existing script title, body, and active status"
    - "User can read a script in a clean, readable view suitable for phone reference during a call"
    - "User can mark a script inactive (soft delete) and it disappears from the default list"
    - "Only active scripts show by default"
  artifacts:
    - path: "crm-dashboard/types/script.ts"
      provides: "Script TypeScript interface"
      contains: "interface Script"
    - path: "crm-dashboard/lib/schemas/scriptSchema.ts"
      provides: "Zod validation schema for script form"
      contains: "scriptSchema"
    - path: "crm-dashboard/components/AddEditScriptDialog.tsx"
      provides: "Create/edit script dialog form using React Hook Form + Zod"
      exports: ["AddEditScriptDialog"]
    - path: "crm-dashboard/components/ScriptCard.tsx"
      provides: "Individual script card with title, status badge, action buttons"
      exports: ["ScriptCard"]
    - path: "crm-dashboard/components/ScriptManager.tsx"
      provides: "Script list manager with CRUD orchestration and script read view"
      exports: ["ScriptManager"]
    - path: "crm-dashboard/components/ui/dialog.tsx"
      provides: "shadcn Dialog component"
    - path: "crm-dashboard/components/ui/textarea.tsx"
      provides: "shadcn Textarea component"
  key_links:
    - from: "crm-dashboard/components/ScriptManager.tsx"
      to: "supabase scripts table"
      via: "createClient().from('scripts').select/insert/update"
      pattern: "from\\(['\"]scripts['\"]\\)"
    - from: "crm-dashboard/components/AddEditScriptDialog.tsx"
      to: "crm-dashboard/lib/schemas/scriptSchema.ts"
      via: "zodResolver(scriptSchema)"
      pattern: "zodResolver.*scriptSchema"
    - from: "crm-dashboard/app/(dashboard)/leads/page.tsx"
      to: "crm-dashboard/components/ScriptManager.tsx"
      via: "import and render ScriptManager with currentClientId prop"
      pattern: "<ScriptManager"
    - from: "crm-dashboard/components/ScriptManager.tsx"
      to: "crm-dashboard/components/ScriptCard.tsx"
      via: "renders ScriptCard for each script"
      pattern: "<ScriptCard"
    - from: "crm-dashboard/components/ScriptManager.tsx"
      to: "crm-dashboard/components/AddEditScriptDialog.tsx"
      via: "renders AddEditScriptDialog when dialog state is open"
      pattern: "<AddEditScriptDialog"
---

<objective>
Build the complete Script Library CRUD feature for the Cold Calling leads page: users can create, read, edit, and soft-delete call scripts via dialog forms, with a collapsible script section above the leads table.

Purpose: Cold callers need managed call scripts to reference during calls. This is the core feature of v1.4.
Output: ScriptManager component wired into leads page with full CRUD operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-script-library-crud/15-RESEARCH.md
@.planning/phases/14-schema-niche-taxonomy/14-01-SUMMARY.md
@.planning/phases/14-schema-niche-taxonomy/14-02-SUMMARY.md

# Source files to READ before modifying
@crm-dashboard/app/(dashboard)/leads/page.tsx
@crm-dashboard/types/lead.ts
@crm-dashboard/types/niche.ts
@crm-dashboard/components/NicheComboBox.tsx
@crm-dashboard/lib/supabase/client.ts
@crm-dashboard/contexts/UserContext.tsx
@crm-dashboard/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create Script type + Zod schema</name>
  <files>
    crm-dashboard/package.json
    crm-dashboard/types/script.ts
    crm-dashboard/lib/schemas/scriptSchema.ts
    crm-dashboard/components/ui/dialog.tsx
    crm-dashboard/components/ui/textarea.tsx
  </files>
  <action>
    1. Install form libraries:
       ```
       cd crm-dashboard
       npm install react-hook-form zod @hookform/resolvers
       ```

    2. Add shadcn Dialog and Textarea components:
       ```
       npx shadcn@latest add dialog textarea
       ```
       These will create `components/ui/dialog.tsx` and `components/ui/textarea.tsx`.
       If shadcn prompts for configuration, accept defaults.

    3. Create `crm-dashboard/types/script.ts`:
       ```typescript
       export interface Script {
         id: string
         client_id: string
         title: string
         body: string
         is_active: boolean
         created_at: string
         updated_at: string
         created_by: string | null
       }
       ```
       This matches the scripts table schema from Phase 14 migration (07_scripts_niches_outcomes.sql).

    4. Create `crm-dashboard/lib/schemas/scriptSchema.ts`:
       ```typescript
       import { z } from 'zod'

       export const scriptSchema = z.object({
         title: z
           .string()
           .min(1, 'Title is required')
           .max(200, 'Title must be 200 characters or less')
           .trim(),
         body: z
           .string()
           .min(1, 'Script body is required')
           .trim(),
       })

       export type ScriptFormValues = z.infer<typeof scriptSchema>
       ```
       NOTE: Do NOT include `is_active` in the form schema. Active/inactive toggling is handled separately via a dedicated action button, not the create/edit form. This keeps the form focused on content.

    5. Verify the build passes:
       ```
       cd crm-dashboard && npm run build
       ```
  </action>
  <verify>
    - `npm run build` passes with no errors
    - `crm-dashboard/types/script.ts` exports `Script` interface
    - `crm-dashboard/lib/schemas/scriptSchema.ts` exports `scriptSchema` and `ScriptFormValues`
    - `crm-dashboard/components/ui/dialog.tsx` exists (shadcn Dialog)
    - `crm-dashboard/components/ui/textarea.tsx` exists (shadcn Textarea)
    - `react-hook-form`, `zod`, `@hookform/resolvers` appear in package.json dependencies
  </verify>
  <done>All dependencies installed, Script type and Zod schema created, shadcn Dialog and Textarea components added, build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create ScriptCard, AddEditScriptDialog, and ScriptManager components</name>
  <files>
    crm-dashboard/components/ScriptCard.tsx
    crm-dashboard/components/AddEditScriptDialog.tsx
    crm-dashboard/components/ScriptManager.tsx
  </files>
  <action>
    Create three components. Read the existing NicheComboBox.tsx and leads/page.tsx first to follow established patterns (createClient(), useUser(), Tailwind classes, error handling style).

    **1. Create `crm-dashboard/components/ScriptCard.tsx`:**

    A card component displaying a single script. Props:
    - `script: Script` -- the script data
    - `onEdit: () => void` -- callback when Edit button clicked
    - `onToggleActive: () => void` -- callback when Mark Inactive/Reactivate clicked
    - `onView: () => void` -- callback when card title/body area clicked (opens read view)

    Implementation:
    - White card with rounded corners and shadow (matching existing `bg-white rounded-lg shadow` pattern)
    - Title as bold text, truncated to 1 line with `truncate`
    - Body preview: first 2-3 lines of script body, truncated with `line-clamp-3` and `whitespace-pre-wrap`
    - Status badge: green "Active" or gray "Inactive" pill (matching STATUS_COLORS pattern from leads page)
    - Bottom row with action buttons: "Edit" (blue text), "Mark Inactive" (red text) or "Reactivate" (green text)
    - The card title/body area is clickable (cursor-pointer) to trigger `onView` for reading the full script
    - Mobile touch targets: buttons should be `min-h-[44px]` with adequate padding
    - Use `lucide-react` icons: `Pencil` for edit, `EyeOff`/`Eye` for toggle active

    **2. Create `crm-dashboard/components/AddEditScriptDialog.tsx`:**

    A single dialog component handling both create and edit modes. Props:
    - `script?: Script` -- if provided, edit mode; if undefined, create mode
    - `clientId: string` -- the client_id to assign on create
    - `open: boolean` -- controls dialog visibility
    - `onClose: () => void` -- close callback (must also call `form.reset()`)
    - `onSaved: () => void` -- callback after successful save (parent refetches scripts)

    Implementation:
    - Use shadcn `Dialog`, `DialogContent`, `DialogHeader`, `DialogTitle` from `@/components/ui/dialog`
    - Use `react-hook-form` with `zodResolver(scriptSchema)` from `@/lib/schemas/scriptSchema`
    - CRITICAL: Use `mode: 'onSubmit'` in useForm config (NOT 'all' or 'onChange'). This prevents the shadcn Dialog close button from triggering validation errors (known pitfall from research).
    - Title field: plain `<input>` with Tailwind styling matching existing form inputs (`w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500`)
    - Body field: shadcn `<Textarea>` with `rows={10}` for adequate editing space. Use `whitespace-pre-wrap` on the textarea.
    - Error messages: red `text-sm text-red-500` below each field when validation fails
    - `defaultValues`: In edit mode, populate from `script.title` and `script.body`. In create mode, empty strings.
    - IMPORTANT: Use a `useEffect` to call `form.reset()` when the `script` prop changes, so switching between edit targets resets the form correctly.
    - Submit handler:
      - Set `isSubmitting` state to true, disable submit button
      - If edit mode (`script` exists): `supabase.from('scripts').update({ title: data.title, body: data.body, updated_at: new Date().toISOString() }).eq('id', script.id)`
      - If create mode: `supabase.from('scripts').insert({ title: data.title, body: data.body, client_id: clientId })`
      - On success: call `onSaved()` then `onClose()`
      - On error: `console.error` + `alert('Failed to save script: ' + error.message)` (matches existing error pattern in leads page)
      - Finally: set `isSubmitting` to false
    - Cancel button: `type="button"` (prevents form submission), calls `onClose()`
    - Submit button: shows "Creating..." or "Saving..." when submitting, "Create Script" or "Save Changes" otherwise
    - Dialog title: "Add New Script" for create, "Edit Script" for edit
    - Use `createClient()` from `@/lib/supabase/client` for Supabase operations

    **3. Create `crm-dashboard/components/ScriptManager.tsx`:**

    The main orchestrator component. Props:
    - `clientId: string` -- the current client ID from useUser context

    State:
    - `scripts: Script[]` -- fetched scripts list
    - `loading: boolean` -- loading state for initial fetch
    - `dialogMode: 'closed' | 'add' | 'edit' | 'view'` -- which dialog is open
    - `selectedScript: Script | undefined` -- the script being edited or viewed

    Implementation:
    - Fetch scripts on mount and when clientId changes:
      ```
      supabase.from('scripts').select('*').eq('client_id', clientId).eq('is_active', true).order('created_at', { ascending: false })
      ```
      NOTE: Default query filters to `is_active = true`. This ensures only active scripts show.
    - Section header: "Call Scripts" with an "Add Script" button (blue, matching existing button style from leads page header)
    - If `loading`: show "Loading scripts..." text
    - If `scripts.length === 0` and not loading: show empty state message "No scripts yet. Create your first call script to get started."
    - If scripts exist: render a responsive grid of ScriptCard components:
      `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4`
    - "Add Script" button click: set `dialogMode = 'add'`, `selectedScript = undefined`
    - ScriptCard `onEdit` callback: set `dialogMode = 'edit'`, `selectedScript = script`
    - ScriptCard `onView` callback: set `dialogMode = 'view'`, `selectedScript = script`
    - ScriptCard `onToggleActive` callback:
      - For active scripts: `window.confirm('Mark this script as inactive? It will be hidden from the list.')` then `supabase.from('scripts').update({ is_active: false, updated_at: new Date().toISOString() }).eq('id', script.id)` then refetch
      - (Inactive scripts won't show by default, so no reactivate needed in this view)
    - `onSaved` callback from AddEditScriptDialog: refetch scripts
    - `onClose` callback: set `dialogMode = 'closed'`, `selectedScript = undefined`

    **Script View Dialog (read mode):**
    Within ScriptManager, when `dialogMode === 'view'` and `selectedScript` exists, render a shadcn Dialog showing the full script content:
    - DialogTitle: the script title
    - Body: `<div className="whitespace-pre-wrap text-base leading-relaxed">{selectedScript.body}</div>`
    - This is the "clean, mobile-optimized view suitable for reference during a call"
    - Full-width dialog content, large readable text (`text-base` or `text-lg` on mobile)
    - The DialogContent should use `className="max-w-2xl max-h-[80vh] overflow-y-auto"` for scrollable long scripts
    - Single "Close" button at the bottom, `min-h-[44px]` for mobile touch target
    - An "Edit" button next to Close that switches to edit mode: set `dialogMode = 'edit'` (keeps `selectedScript`)

    Render the AddEditScriptDialog:
    ```tsx
    <AddEditScriptDialog
      script={dialogMode === 'edit' ? selectedScript : undefined}
      clientId={clientId}
      open={dialogMode === 'add' || dialogMode === 'edit'}
      onClose={() => { setDialogMode('closed'); setSelectedScript(undefined) }}
      onSaved={() => fetchScripts()}
    />
    ```

    Use `createClient()` from `@/lib/supabase/client`.
  </action>
  <verify>
    - `npm run build` passes with no TypeScript errors
    - ScriptCard.tsx exports ScriptCard component
    - AddEditScriptDialog.tsx exports AddEditScriptDialog component
    - ScriptManager.tsx exports ScriptManager component
    - ScriptManager imports and uses ScriptCard and AddEditScriptDialog
    - AddEditScriptDialog uses `zodResolver(scriptSchema)` with `mode: 'onSubmit'`
    - Supabase queries filter by `is_active = true` and `client_id = clientId`
  </verify>
  <done>Three script components created: ScriptCard (display), AddEditScriptDialog (create/edit form with RHF+Zod), ScriptManager (list + CRUD + view dialog). All import correctly and build passes.</done>
</task>

<task type="auto">
  <name>Task 3: Wire ScriptManager into the Cold Calling leads page</name>
  <files>
    crm-dashboard/app/(dashboard)/leads/page.tsx
  </files>
  <action>
    Read the existing `crm-dashboard/app/(dashboard)/leads/page.tsx` before modifying.

    Add the ScriptManager component to the leads page as a collapsible section above the leads table. This page is the Cold Calling leads page (only shows for clients with `client_type = 'leads_only'`).

    1. Add imports at the top of the file:
       ```typescript
       import { ScriptManager } from '@/components/ScriptManager'
       ```

    2. Add a `scriptsExpanded` state variable:
       ```typescript
       const [scriptsExpanded, setScriptsExpanded] = useState(true)
       ```

    3. Add the ScriptManager section BETWEEN the filters section and the leads table section. It should be rendered conditionally -- only when `currentClientId` exists (same guard used for the "Add Lead" button):
       ```tsx
       {currentClientId && (
         <div className="bg-white rounded-lg shadow mb-6">
           <button
             onClick={() => setScriptsExpanded(!scriptsExpanded)}
             className="w-full flex items-center justify-between px-6 py-4 text-left"
           >
             <h2 className="text-lg font-semibold text-gray-900">Call Scripts</h2>
             <span className="text-gray-400 text-sm">
               {scriptsExpanded ? 'Hide' : 'Show'}
             </span>
           </button>
           {scriptsExpanded && (
             <div className="px-6 pb-6">
               <ScriptManager clientId={currentClientId} />
             </div>
           )}
         </div>
       )}
       ```

    4. NOTE: The ScriptManager handles its own header with the "Add Script" button inside it. So the collapsible wrapper just needs the section title and expand/collapse toggle. Remove the "Call Scripts" h2 from inside ScriptManager if it duplicates the wrapper title -- OR rename the ScriptManager header to just show the "Add Script" button without a redundant title. The cleaner approach: ScriptManager should NOT have its own h2 title. It should just render the "Add Script" button row + grid of cards + dialogs. The section title "Call Scripts" lives in the wrapper on the leads page.

    Actually, to keep ScriptManager self-contained and reusable: keep the "Add Script" button inside ScriptManager but remove the h2 title from ScriptManager (since the wrapper provides it). ScriptManager renders: top row with just the "Add Script" button right-aligned, then the cards grid, then dialogs.

    5. Verify the build passes:
       ```
       cd crm-dashboard && npm run build
       ```
  </action>
  <verify>
    - `npm run build` passes with no errors
    - The leads page imports ScriptManager
    - ScriptManager is rendered conditionally when `currentClientId` exists
    - The scripts section is collapsible (scriptsExpanded state)
    - The scripts section appears between filters and the leads table
  </verify>
  <done>ScriptManager wired into the Cold Calling leads page as a collapsible section. Users see their call scripts above the leads list. Scripts can be created, edited, viewed, and soft-deleted. Only active scripts show by default. Build passes.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   ```
   cd crm-dashboard && npm run build
   ```
   Must pass with zero errors.

2. File existence check:
   - `crm-dashboard/types/script.ts` exists
   - `crm-dashboard/lib/schemas/scriptSchema.ts` exists
   - `crm-dashboard/components/ui/dialog.tsx` exists
   - `crm-dashboard/components/ui/textarea.tsx` exists
   - `crm-dashboard/components/ScriptCard.tsx` exists
   - `crm-dashboard/components/AddEditScriptDialog.tsx` exists
   - `crm-dashboard/components/ScriptManager.tsx` exists

3. Import chain verification:
   - leads/page.tsx imports ScriptManager
   - ScriptManager imports ScriptCard, AddEditScriptDialog, Script type, createClient
   - AddEditScriptDialog imports scriptSchema, zodResolver, Dialog, Textarea
   - ScriptCard imports Script type

4. Key patterns present:
   - `from('scripts')` queries include `.eq('is_active', true)` filter
   - `from('scripts')` queries include `.eq('client_id', clientId)` filter
   - AddEditScriptDialog uses `mode: 'onSubmit'` in useForm config
   - Submit buttons show loading state and are disabled during submission
   - Script view uses `whitespace-pre-wrap` for newline preservation
</verification>

<success_criteria>
- User can see a "Call Scripts" collapsible section on the Cold Calling leads page
- User can create a new script with title and body via the Add Script dialog
- User can edit an existing script (title and body) via the Edit action
- User can read a full script in a clean dialog view with preserved formatting
- User can mark a script inactive (it disappears from the active list)
- Only active scripts display by default
- All touch targets are minimum 44x44px for mobile usability
- Build passes with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-script-library-crud/15-01-SUMMARY.md`
</output>
