---
phase: 16-outcome-tracking
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - crm-dashboard/components/RecordOutcomeDialog.tsx
  - crm-dashboard/components/ScriptCard.tsx
  - crm-dashboard/components/ScriptManager.tsx
autonomous: true

must_haves:
  truths:
    - "User can open a record outcome dialog from a script card, select a lead, and mark the outcome as success or fail with large phone-friendly buttons (48x48px minimum)"
    - "Each outcome is permanently linked to both a lead and a script via script_lead_outcomes table upsert"
    - "If an outcome already exists for a script+lead pair, the previous result and notes are shown and can be updated"
    - "Script cards display aggregated counters (success count, fail count, win rate percentage) derived from get_script_outcome_stats RPC"
    - "User can add optional notes when recording an outcome"
  artifacts:
    - path: "crm-dashboard/components/RecordOutcomeDialog.tsx"
      provides: "Outcome recording form with lead selector, outcome buttons, notes"
      min_lines: 80
    - path: "crm-dashboard/components/ScriptCard.tsx"
      provides: "Script card with stats row and Record Call button"
      contains: "win_rate"
    - path: "crm-dashboard/components/ScriptManager.tsx"
      provides: "Extended dialog state machine with record-outcome mode and RPC stats fetching"
      contains: "record-outcome"
  key_links:
    - from: "crm-dashboard/components/RecordOutcomeDialog.tsx"
      to: "script_lead_outcomes table"
      via: "Supabase .upsert() with onConflict: 'script_id,lead_id'"
      pattern: "onConflict.*script_id,lead_id"
    - from: "crm-dashboard/components/RecordOutcomeDialog.tsx"
      to: "crm-dashboard/components/ScriptManager.tsx"
      via: "onSaved callback triggers fetchScriptsAndStats refetch"
      pattern: "onSaved"
    - from: "crm-dashboard/components/ScriptManager.tsx"
      to: "get_script_outcome_stats RPC"
      via: "supabase.rpc() call on mount and after outcome save"
      pattern: "rpc.*get_script_outcome_stats"
    - from: "crm-dashboard/components/ScriptCard.tsx"
      to: "crm-dashboard/types/script.ts"
      via: "ScriptWithStats type for stats prop"
      pattern: "ScriptWithStats"
---

<objective>
Build the outcome tracking UI: RecordOutcomeDialog for recording per-lead call outcomes, ScriptCard with aggregated stats display, and ScriptManager wiring with extended dialog state machine.

Purpose: This is the core user-facing feature of Phase 16 -- users can record call outcomes tied to scripts and see win rates directly on script cards.

Output: One new component (RecordOutcomeDialog) and two enhanced components (ScriptCard, ScriptManager).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-outcome-tracking/16-RESEARCH.md
@.planning/phases/16-outcome-tracking/16-01-SUMMARY.md

# Source files to read before implementation
@crm-dashboard/components/ScriptManager.tsx
@crm-dashboard/components/ScriptCard.tsx
@crm-dashboard/components/NicheComboBox.tsx
@crm-dashboard/components/AddEditScriptDialog.tsx
@crm-dashboard/types/script.ts
@crm-dashboard/types/lead.ts
@crm-dashboard/lib/schemas/outcomeSchema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RecordOutcomeDialog component</name>
  <files>crm-dashboard/components/RecordOutcomeDialog.tsx</files>
  <action>
Create `RecordOutcomeDialog.tsx` -- a dialog for recording call outcomes per lead for a given script.

**Props interface:**
```typescript
interface RecordOutcomeDialogProps {
  script: Script
  clientId: string
  open: boolean
  onClose: () => void
  onSaved: () => void
}
```

**Lead selector -- use relative-positioned dropdown pattern from NicheComboBox, NOT Radix Popover:**

CRITICAL: Do NOT use `Popover`/`PopoverContent`/`PopoverTrigger` from Radix. The research mentions Popover but the Phase 14 lesson learned is that Radix Popover renders behind Dialog (portal-behind-dialog z-index bug). The NicheComboBox in `crm-dashboard/components/NicheComboBox.tsx` demonstrates the correct pattern:
- Use a `<div ref={containerRef} className="relative">` wrapper
- Toggle `open` state on button click
- Render dropdown as `<div className="absolute z-50 mt-1 w-full rounded-md border bg-white shadow-lg">` when open
- Close on outside click via `mousedown` event listener on document
- Search input inside dropdown for filtering leads
- Show lead name (first_name + last_name) and email as fallback when name is null
- Max height with overflow scroll: `max-h-[200px] overflow-y-auto`

Follow the NicheComboBox implementation closely but adapt for leads:
- No "create new" option (leads already exist)
- No "(None)" option (lead is required)
- Display: `first_name last_name` primary, `email` secondary. If first_name and last_name are both null, show email as primary.
- Filter by: first_name, last_name, email (case-insensitive)

**Wrap in React Hook Form Controller** for validation:
```typescript
const form = useForm<OutcomeFormValues>({
  resolver: zodResolver(outcomeSchema),
  mode: 'onSubmit',
})
```
Use `<Controller name="lead_id" control={form.control} render={...} />` around the dropdown trigger button so that `form.trigger()` validates lead_id before submission.

**Existing outcome loading:**
When a lead is selected (`lead_id` changes via `form.watch('lead_id')`), check if an outcome already exists for this script+lead pair:
```typescript
const { data: existing } = await supabase
  .from('script_lead_outcomes')
  .select('*')
  .eq('script_id', script.id)
  .eq('lead_id', selectedLeadId)
  .maybeSingle()
```
If found, display the existing outcome as a status badge above the outcome buttons (e.g., "Current: Success" in green or "Current: Failed" in red), and pre-fill the notes textarea with `existing.notes`. This satisfies Success Criterion 3 (upsert behavior with previous result shown).

**Outcome buttons (ABOVE notes textarea -- mobile keyboard won't cover them):**
- Two large buttons: "Success" (green, Check icon) and "Failed" (red, X icon)
- `min-h-[48px] min-w-[48px]` for 48x48px touch targets
- Vertical stack on mobile (`flex-col`), horizontal on desktop (`md:flex-row`)
- `gap-3` between buttons (12px spacing to prevent accidental touches)
- Disabled during submission (`isSubmitting` state)
- Each button calls `handleOutcome('success')` or `handleOutcome('fail')`

**handleOutcome function:**
1. Call `form.trigger()` to validate lead_id -- return early if invalid
2. Get `lead_id` and `notes` from `form.getValues()`
3. Set `isSubmitting = true`
4. Upsert to `script_lead_outcomes`:
   ```typescript
   await supabase.from('script_lead_outcomes').upsert({
     script_id: script.id,
     lead_id,
     outcome,
     notes: notes || null,
   }, {
     onConflict: 'script_id,lead_id', // NO space after comma
   })
   ```
5. On success: call `onSaved()` (parent refetches stats and closes dialog)
6. On error: `console.error` + `alert()` (matches existing pattern)
7. Set `isSubmitting = false`

**Notes textarea (BELOW outcome buttons):**
- Use `{...form.register('notes')}`
- Label: "Notes" with "(optional)" in gray
- Placeholder: "Objections, follow-up timing, next steps..."
- 3 rows

**Dialog header:**
- Title: "Record Call Outcome"
- Subtitle: "Script: {script.title}" in gray text

**Cancel button** at bottom right.

**Fetch leads on mount:**
```typescript
useEffect(() => {
  const fetchLeads = async () => {
    const { data } = await supabase
      .from('leads')
      .select('id, first_name, last_name, email')
      .eq('client_id', clientId)
      .order('first_name', { ascending: true })
    setLeads(data || [])
  }
  fetchLeads()
}, [clientId])
```

**Imports:** Use `Dialog`, `DialogContent`, `DialogHeader`, `DialogTitle` from `@/components/ui/dialog`. Use `Textarea` from `@/components/ui/textarea`. Use `Check`, `X` from `lucide-react`. Use `Controller` from `react-hook-form`. Import `outcomeSchema`, `OutcomeFormValues` from `@/lib/schemas/outcomeSchema`. Import `Script` from `@/types/script`.
  </action>
  <verify>
1. Read RecordOutcomeDialog.tsx and verify:
   - NO imports from `@/components/ui/popover` (no Radix Popover)
   - Uses relative-positioned dropdown with `containerRef` and `absolute z-50` positioning
   - Lead selector wrapped in Controller with form.control
   - onConflict value is exactly `'script_id,lead_id'` (no spaces)
   - Existing outcome is fetched when lead_id changes
   - Outcome buttons have `min-h-[48px]`
   - Outcome buttons are ABOVE the notes textarea
   - Notes field uses `form.register('notes')`
   - form.trigger() called before handleOutcome submission
2. `cd crm-dashboard && npx tsc --noEmit` passes (no type errors)
  </verify>
  <done>
RecordOutcomeDialog component exists with:
- Relative-positioned lead dropdown (NOT Radix Popover)
- Controller-wrapped lead selector with validation
- Existing outcome pre-loading when lead selected
- 48x48px outcome buttons above notes textarea
- Supabase upsert with onConflict: 'script_id,lead_id'
- Optional notes with register pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: ScriptCard stats + ScriptManager integration</name>
  <files>crm-dashboard/components/ScriptCard.tsx, crm-dashboard/components/ScriptManager.tsx</files>
  <action>
**ScriptCard.tsx modifications:**

1. Change props interface to accept `ScriptWithStats` instead of `Script`:
   ```typescript
   import type { ScriptWithStats } from '@/types/script'
   import { Phone } from 'lucide-react'

   interface ScriptCardProps {
     script: ScriptWithStats  // was: Script
     onEdit: () => void
     onToggleActive: () => void
     onView: () => void
     onRecordOutcome: () => void  // NEW
   }
   ```

2. Add a stats row between the card content and the action buttons. Only show when `script.stats.total_count > 0`:
   ```tsx
   {script.stats.total_count > 0 && (
     <div className="px-4 py-2 border-t border-gray-100 flex items-center gap-4 text-sm">
       <span className="text-green-600 font-medium">{script.stats.success_count} won</span>
       <span className="text-red-600 font-medium">{script.stats.fail_count} lost</span>
       <span className="text-gray-500">{script.stats.win_rate}%</span>
     </div>
   )}
   ```

3. Add "Record Call" button in the action buttons row (alongside Edit and Mark Inactive):
   ```tsx
   <button
     onClick={(e) => { e.stopPropagation(); onRecordOutcome(); }}
     className="text-blue-600 hover:text-blue-800 text-sm flex items-center gap-1 min-h-[44px] px-2"
   >
     <Phone className="h-4 w-4" />
     Record Call
   </button>
   ```
   Place it as the FIRST button in the actions div (leftmost position, most accessible).

**ScriptManager.tsx modifications:**

1. Extend DialogMode type:
   ```typescript
   type DialogMode = 'closed' | 'add' | 'edit' | 'view' | 'record-outcome'
   ```

2. Change state type from `Script[]` to `ScriptWithStats[]`:
   ```typescript
   import type { ScriptWithStats, OutcomeStats } from '@/types/script'
   const [scripts, setScripts] = useState<ScriptWithStats[]>([])
   ```

3. Replace `fetchScripts` with `fetchScriptsAndStats`:
   ```typescript
   const fetchScriptsAndStats = async () => {
     setLoading(true)

     // Fetch scripts
     const { data: scriptsData, error: scriptsError } = await supabase
       .from('scripts')
       .select('*')
       .eq('client_id', clientId)
       .eq('is_active', true)
       .order('created_at', { ascending: false })

     if (scriptsError) {
       console.error('Error fetching scripts:', scriptsError)
       setLoading(false)
       return
     }

     // Fetch stats via RPC
     const { data: statsData } = await supabase
       .rpc('get_script_outcome_stats', { p_client_id: clientId })

     // Join scripts with stats
     const defaultStats: OutcomeStats = {
       script_id: '',
       success_count: 0,
       fail_count: 0,
       total_count: 0,
       win_rate: 0,
     }

     const scriptsWithStats: ScriptWithStats[] = (scriptsData || []).map(script => ({
       ...script,
       stats: statsData?.find((s: OutcomeStats) => s.script_id === script.id) || { ...defaultStats, script_id: script.id },
     }))

     setScripts(scriptsWithStats)
     setLoading(false)
   }
   ```

4. Update all references from `fetchScripts` to `fetchScriptsAndStats`:
   - useEffect on mount
   - onSaved callback for AddEditScriptDialog
   - handleToggleActive success path

5. Add `handleRecordOutcome`:
   ```typescript
   const handleRecordOutcome = (script: ScriptWithStats) => {
     setDialogMode('record-outcome')
     setSelectedScript(script)
   }
   ```

6. Add `handleOutcomeSaved`:
   ```typescript
   const handleOutcomeSaved = async () => {
     await fetchScriptsAndStats()  // Refetch to update counters
     handleCloseDialog()
   }
   ```

7. Pass `onRecordOutcome` to ScriptCard in the grid:
   ```tsx
   <ScriptCard
     key={script.id}
     script={script}
     onEdit={() => handleEditScript(script)}
     onView={() => handleViewScript(script)}
     onToggleActive={() => handleToggleActive(script)}
     onRecordOutcome={() => handleRecordOutcome(script)}
   />
   ```

8. Add RecordOutcomeDialog render block (after the view dialog block):
   ```tsx
   import { RecordOutcomeDialog } from './RecordOutcomeDialog'

   {dialogMode === 'record-outcome' && selectedScript && (
     <RecordOutcomeDialog
       script={selectedScript}
       clientId={clientId}
       open={true}
       onClose={handleCloseDialog}
       onSaved={handleOutcomeSaved}
     />
   )}
   ```

9. Update `selectedScript` type to `ScriptWithStats | undefined` if needed (it's used for both view dialog and record-outcome dialog).

IMPORTANT: The `handleEditScript` and `handleViewScript` handlers will pass `ScriptWithStats` objects, which are supersets of `Script`. The AddEditScriptDialog expects `Script` -- this is fine since TypeScript structural typing allows passing a supertype. But double-check that view dialog and AddEditScriptDialog still work correctly with the extended type.
  </action>
  <verify>
1. Read ScriptCard.tsx and verify:
   - Props use ScriptWithStats type
   - Stats row displays success count, fail count, win rate
   - Stats row only shows when total_count > 0
   - "Record Call" button with Phone icon exists
   - onRecordOutcome prop is used
2. Read ScriptManager.tsx and verify:
   - DialogMode includes 'record-outcome'
   - scripts state uses ScriptWithStats[]
   - fetchScriptsAndStats fetches both scripts and RPC stats
   - RecordOutcomeDialog is conditionally rendered
   - onSaved triggers fetchScriptsAndStats (refetches counters)
3. `cd crm-dashboard && npx next build` passes
  </verify>
  <done>
- ScriptCard shows stats row (success/fail/win rate) when outcomes exist
- ScriptCard has "Record Call" button
- ScriptManager extends dialog state machine with 'record-outcome' mode
- ScriptManager fetches scripts AND stats via RPC on mount
- ScriptManager refetches stats after outcome saved (counters update immediately)
- RecordOutcomeDialog is wired into ScriptManager's dialog flow
  </done>
</task>

</tasks>

<verification>
All 5 Phase 16 success criteria covered:

1. "User can open a script call dialog, select a lead, and mark the outcome as success or fail with large phone-friendly buttons (48x48px minimum)"
   - RecordOutcomeDialog opens from ScriptCard "Record Call" button
   - Lead combobox with search (relative-positioned, NOT Radix Popover)
   - 48x48px success/fail buttons

2. "Each outcome is permanently linked to both a lead and a script -- no orphaned or standalone counters"
   - Upsert to script_lead_outcomes with script_id + lead_id
   - UNIQUE constraint enforces one outcome per pair
   - Counters derived from RPC aggregation (not independent values)

3. "If an outcome already exists for a script+lead pair, the previous result is shown and can be updated (upsert behavior)"
   - RecordOutcomeDialog fetches existing outcome when lead_id changes
   - Shows "Current: Success/Failed" badge and pre-fills notes
   - Upsert with onConflict: 'script_id,lead_id' updates existing row

4. "Script cards on the Cold Calling page display aggregated counters derived from script_lead_outcomes"
   - ScriptCard stats row shows success_count, fail_count, win_rate
   - Stats from get_script_outcome_stats RPC (LEFT JOIN handles zero-outcome scripts)

5. "User can add optional notes when recording an outcome"
   - Notes textarea with form.register('notes'), optional in Zod schema
   - Pre-filled from existing outcome if one exists

Build verification:
- `cd crm-dashboard && npx next build` passes with no errors
- All existing functionality preserved (add/edit/view/toggle still work)
</verification>

<success_criteria>
- RecordOutcomeDialog renders with relative-positioned lead dropdown (no Radix Popover portal bugs)
- Outcome upsert uses onConflict: 'script_id,lead_id' (no spaces, matches UNIQUE constraint)
- Existing outcomes pre-loaded when lead selected (shows current result + notes)
- ScriptCard displays stats row only when total_count > 0
- ScriptManager refetches stats after outcome save (counters update immediately)
- Build passes, no regressions in existing script CRUD
</success_criteria>

<output>
After completion, create `.planning/phases/16-outcome-tracking/16-02-SUMMARY.md`
</output>
